package s62

/*
一个机器人位于一个 m x n网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？



动态规划题目：
先按照暴力解法画图
然后根据图去找最优子结构（重复结构）
然后找状态转移公式
然后，看怎么存储中间状态

这个题目只能往右，往下走，这是前提。
然后，然后看走到第i步的可能性，就是它下方的可能性加上右边的可能性
得出递推公式



*/


// m * n 的放个
// m 是行  n 是列
func uniquePaths(m int, n int) int {

	
	// 递推公式
	// 自底向上
	// opt[i][j] = opt[i+1][j] + opt[i][j+1]
	
	// 最后一列和最后一行，只能是1，因为他们只能朝一个方向走
	// 所以这里初始化最后一行，最后一列不计算是因为没有必要
	// 因为都是1  只需要一个记录即可
	cur := make([]int,0)
	for i := 0; i < n; i++ {
		cur = append(cur, 1)
	}

	for j := m-1 ; j>0 ;j--{
		for i := n -2 ; i >=0 ;i--{
			cur[i] += cur [i + 1]
			print(cur[i],"\t")
		}
		println()
	}

	return cur[0]





}
