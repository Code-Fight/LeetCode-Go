package s53

/*
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

思路：
暴力法就是，先从-2开始，依次计算与所有的组合的结果。
-2  -2,1  -2,1,-3  -2,1,-3,4 ...
1   1,-3  1,-3,4   1,-3,4,-1 ...
然后，把所有的结果计算出来即可
由上面的推理可以看出，第二行的值，都是在减去第一行的某个元素的子集
比如： -2，1 和 1    -2,1,-3 和 1,-3
所以，肯定有子问题
可以看出，求 [-2,1,-3,4,-1,2,1,-5,4] ，就等于 [1,-3,4,-1,2,1,-5,4] 再加上组合 -2 的结果，依次可知

problem(i) = sum(i-1) + a[i]

但是，这里还可以断开从某个位置开始，不需要非要前面的一堆负数，这样结果会更大一些。
所以最终公式如下：problem(i) = max (sum(i-1) + a[i], a[i])
DP状态即使DP[i]  存储前面节点计算出来的结果


*/

func maxSubArray(nums []int) int {

	// 这里其实可以直接使用nums 作为dp状态
	// 为了显示的更清晰，先这么写
	dp := make([]int, 0)
	dp = append(dp, nums...)
	max := func(a, b int) int {
		if a > b {
			return a
		}
		return b
	}
	// 开辟一个内存来存储计算过程中的最大值，
	// 否则还得遍历最后的结果
	maxSum := 0
	if len(dp) > 0 {
		maxSum = dp[0]
	}

	// 第一个元素不需要遍历
	for i := 1; i < len(nums); i++ {
		// DP递推公式
		dp[i] = max(nums[i], dp[i-1]+nums[i])
		if maxSum < dp[i] {
			maxSum = dp[i]
		}
	}
	return maxSum
}
