package s1143

/*
给定两个字符串 text1 和text2，返回这两个字符串的最长公共子序列的长度。

一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。
例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

若这两个字符串没有公共子序列，则返回 0。

代表的意思是：如果相同，说明当前字符可以让路径变的更长，所以加1，如果不同，说明当前字符不影响路径，所以，继承上一级的即可。

思路：
先看图片
有一个特性：
如果当前字符相同，那么就是除去当前字符之外的结果，也就是左上方的值，再加1
如果当前字符不相同，那么就是上一层的值的最大值

解题方式：
两种，一种是先初始化最外面的层 相当于初始化 dp 的 base 状态
还有一种是利用特性，直接多分配一层的二维变量，这样就不用单独写初始化的过程

然后再遍历即可，一层

！！！这里是个注意点！！！
这里一定要记住一点，如果再遇到需要比较大小的情况，尽可能手写一个比较大小，尽量不要用math包，因为只支持float64，所以得类型转换
还得再转换回去，比较浪费。




*/

func longestCommonSubsequence(text1 string, text2 string) int {

	// 自顶向下计算
	// DP状态定义：opt[i][j]
	// DP base 状态 : 分别找一个字符和另外两个串的共通 最大 1 参考图片
	// DP递推公式：
	// 如果最后一个字符相同: opt[i][j] = max(opt[i-1][j],opt[i][j-1])+1
	// 如果最后一个字符不同: opt[i][j] = opt[i-1][j-1])
	// text 1 横向 横向是第二个索引
	// text 2 纵向 纵向是第一个索引
	opt := make([][]int, len(text2)+1)

	// 常规的做法是 先初始化 base opt 状态
	// 但是这里，可以利用数组初始化的特性 初始化后就是 0
	// 然后，再多分配一些数组
	// 这样可以省去单独初始化的过程，然后再遍历

	for i := 0; i < len(opt); i++ {
		opt[i] = make([]int, len(text1)+1)
	}

	max := func(x, y int) int {
		if x > y {
			return x
		}
		return y
	}

	// 开始遍历所有的节点，
	// 根据前面提到的技巧，只判断最后一个节点即可
	// 如果相同就取最大的并加1 ，否则只取最大的即可
	for i := 1; i <= len(text2); i++ {
		for j := 1; j <= len(text1); j++ {
			// 这里比较的时候 主要要比较上一层节点的对比
			if text2[i-1] == text1[j-1] {
				opt[i][j] = opt[i-1][j-1] + 1
			} else {
				opt[i][j] = max(opt[i][j-1], opt[i-1][j])
			}
		}
	}
	return opt[len(text2)][len(text1)]

}
